{:title "Notes on Optimizing Clojure Code 1: Overview"
 :layout :post
 :tags ["clojure"]}

Over the month of December, I've spent a lot of time trying to optimize my
solutions to [Advent of Code][aoc], with reasonable success. I thought I'd
collect my learnings in a set of notes for my future self, and share that with
you. Not all of this is Clojure-specific, but the details mostly are.

### Why optimize code?

For the sake of argument, let's assume you need to make your code faster
because it is too slow for the context it's being run in. In the case of Advent
of Code, I'm putting on myself the arbitrary constraint of running each day
under a second. That's pretty easy for the first few days, but gets a bit
harder on the later challenges.

In a more realistic context, maybe you have a website that's not as snappy as
you'd want, or you have to run a batch job every hour and it's taking 63
minutes and growing, or you have to run a script on your laptop and wait for it
to finish before you can do something else.

Whatever the details, context matters in two very specific ways:

1. It can tell us when to stop. Once your code is "fast enough", you don't need
   to optimize it further. Optimizing code often (though not always) comes at a
   cost to maintainability, so it should be done with some amount of reluctance on
   long-lived production code.
2. It tells us _how much_ code we need to care about. Specifically, all of the
   code involved in the realistic use-case that is currently "too slow", but
   not the rest of the code. This is really important if you want to be efficient
   in your optimization efforts, especially on large code bases.

### The process of optimizing code

In most cases, when a software application is too slow, the vast majority of
its time is spent in a very small fraction of the code, which we therefore call
"the bottleneck". Optimizing is an iterative process that goes a bit like this:

1. Find a section of code that is too slow for some inputs. This is usually
   done with the help of some _profiling_ techniques.
2. Create a _benchmark_ that exercises that section of code with a
   representative set of inputs. In simple cases this is just a new entrypoint
   in your application; in extreme cases it may be a separate project containing
   only the code you want to focus on optimizing.
3. Iterate on the benchmark until it is fast enough.
4. Integrate your optimizations in the main code and try it on real use-cases
   again. If it's now fast enough, you're done. If you identify new cases for
   which it's too slow, keep going.

It's worth noting that all of that is a bit fractal (or recursive): on a large
enough code base, you may want to split a large, slow piece of code into
multiple pieces you optimize separately. The principles are the same at every
level: identify which piece is the slowest, isolate it to a new benchmark, and
work on it until it's fast enough. Then check if you need to do the next piece
(you may be fast enough already).

And that's the rough outline of this series. I'll write one post on profiling,
one on benchmarking, and then a series of posts about various optimization
techniques I've used.

[aoc]: https://adventofcode.com
