{:title "Monads, part four: What if I'm not writing Haskell?"
 :layout :post
 :tags ["monad-tutorial"]}

In the past [two][three] [posts][four] of [this series][monads], I have shown
what I believe to be a simple, effective technique for creating monads in
Haskell. At this point one may be wondering how that translates to other
languages, if indeed it applies at all.

In this post, I will take a look at what exactly we need from a language in
order to apply this "structural monad" approach, with a detailed example in
Clojure.

### Requirements

Let's first look at what we need to be able to use this approach at all. There
are three steps to consider:

1. Defining the structure of a monad.
2. Defining a `run` function that assigns the correct meaning to a monadic
   structure.
3. Being able to write specific instances of monadic structures.

To define the structure, the first thing we need is a way to create a structure
for the various monadic actions. This could be a type, as we did in Haskell;
this could be a set of classes, as we did in Java. All we need here is really
just tagged collections of values; any way to represent that can work, from
actual types to tuples, vectors, lists, or associative collections.

We also need support for first-class functions: at the very least, the
structure representing a `bind` action will need to embed a function. In order
to build up specific instances of monadic structures, we also need some form of
lambda (i.e. literal, anonymous function) syntax, otherwise we will not be able
to build up nested `bind` calls and therefore we won't be able to actually
_bind_ the results of previous steps. And without that, we can't even express
the third monadic law.

Finally, whatever means of tagging individual monadic actions we chose when
defining the structure needs to be "switchable on" in the `run` function. In
our Haskell examples, we used pattern matching to that effect; in our Java
examples, we used inheritance, tough we could also have gone for `instanceof`
calls. Or a switch on `.getClass().getSimpleName()`. If we represent individual
monadic actions as associative data structures, say objects in JavaScript, we
could just have a `tag` key with a string, and match on that.

That's pretty much it, really: some way to group values, some way to tag those
groups, and lambdas.

### Nice-to-haves

Implementing and using monads in JavaScript is doable; it has all of the
requirements. It may not be very pleasant, however, nor very lightweight. There
are a number of things a language can have that will make this process easier.
Here are some of them.

Types are the most obvious one. Types can help with any piece of code, but
using monads usually means juggling slightly more complex types than one would
usually juggle, and the more complex types you use, the more opportunities you
have to screw up and the more value you get from a type system. Note that this
does not necessarily mean "a type system that can express `Monad`"; as we saw
in [part one][one], the Java type system cannot express a `Monad` interface,
yet it can still be leveraged to ensure that monadic values are properly
constructed _for a given monad_.

Generalized tail call elimination is also a big plus. In simple cases monadic
structures will not be very deeply nested, so this may not be a very apparent
problem at first, but the most natural expression for the `run` method will
often be a recursive one. It is always possible to rewrite recursive code to
avoid recursion, but in the case of a monadic `run` method it would add
accidental complexity to what may already be considered as non-straightforward
code.

Pattern matching can make writing the `run` method a lot cleaner. Alternatives
like switch statements and inheritance can work, but switch statements will
tend to be a bit more clunky as they will require some ad-hoc way to extract
components in each branch, and inheritance will have the effect of splitting
what should be a single function's logic across many classes, making it a bit
difficult to keep track of the overall behaviour.

Finally, of course, having special syntax for building up monadic values is
also a big plus. As we saw in our Java examples (mostly in parts [one] and
[two]), it is _possible_ to build up monadic structures simply by nesting
literal `bind` calls (assuming we have lambdas), but it gets a bit tedious.

### Clojure example

I did not set out to write that code with a monad.


[one]: /posts/2021-04-18-monads-1
[two]: /posts/2021-04-25-monads-2
[three]: /posts/2021-05-02-monads-3
[three]: /posts/2021-05-02-monads-3
[four]: /posts/2021-05-09-monads-4
[monads]: /tags/monad-tutorial
