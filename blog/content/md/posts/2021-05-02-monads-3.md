{:title "Monads, part three: monads made easy"
 :layout :post
 :tags ["monad-tutorial"]}

In the previous three parts of this series ([zero], [one], [two]), I have tried
to explain what makes something "a monad" and why and when you could want to
use one. In this post, I will show you a simple process to create a brand new
monad tailor-made for a particular use-case, and walk through a couple
examples.

### Factoring monads

To reiterate, a monad is a way to define an abstract machine with different
computational semantics. In a sense, the monadic abstraction is the reification
of the Church-Turing equivalence: it's an easy, cheap way to simulate other
models of computation (e.g. Turing machine/imperative programming) from lambda
calculus (i.e. functional programming). This is made easy by decomposing the
notion of an abstract machine into three essential components:

- Pure computation. All computing models still have some "leaf" computations
  that are just pure arithmetic, and if you start with a language that can
  handle those, there is no need to reinvent the wheel here. The cheapness of
  monads as a mini-language implementation mechanism mostly comes from this fact:
  that you can reuse your host language for the purely computational part of the
  new language.
- Sequencing pure computations and effects. Structurally, `bind` gives monads
  an opportunity to interleave simulated effects with computation. While we've
  not really done that in the previous posts, one could think of constructing a
  monadic value as purely describing the desired sequence of interleaved
  computations and effects.
- Execution. Once we have a description of what we want to happen, we can make
  it happen. This is the role of the `run` function, which from this
  perspective is an integral part of what makes a given monad useful.

This decomposition suggests a starker demarcation between constructing a
monadic value and executing it than we've done in the past few posts; let's
first walk through the abstract process of creating a monad based on this
decomposition, then we'll look at some examples.

### Monad factory

For the first part, we have literally nothing to do, and that's the magic of
it. We can rely entirely on the host language for all of the pure computations.
If we think of the second part (hereafter "step 1") as defining _structure_, it
follows that it should be possible to define it purely as a data type. This
turns out to be the case, though in order to capture this data type precisely
in a type system we are going to need some features that are not available in
Java, or indeed in standard Haskell[^1]. Finally, the third (hereafter "step
2") part is pretty much just writing a function. At this point, we essentially
have a data structure representing a language to evaluate (but where all
computations are host-language functions), and we can just implement a tiny
interpreter that only needs to care about effects (as computations are taken
care of by the host language already).

[^1]: Standard Haskell is not what most people mean when they say "Haskell"; in
  practice, everyone talking about Haskell means [GHC], and GHC _does_ have all
the support we need.

Because `bind` (`>>=`) and `return` always have the same _structure_ and differ
only in terms of their assigned _meaning_, their definition as of step 1 is
always going to be the same. Here is a "naked", meaningless monadic structure
definition in Haskell:

```haskell
{-# LANGUAGE GADTs #-}
import Control.Monad (ap,liftM)

instance Functor MyMonad where fmap = liftM
instance Applicative MyMonad where pure = return; (<*>) = ap
instance Monad MyMonad where return = Return; (>>=) = Bind

data MyMonad a where
  Bind :: MyMonad a -> (a -> MyMonad b) -> MyMonad b
  Return :: a -> MyMonad a
```

That's it. This part will always be the same for all monads (modulo the name of
the data type we're defining, which in most case you'll want to be more
specific than just `MyMonad`). With this definition, you can write:

```haskell
example :: MyMonad Int
example = do
  a <- pure 15
  b <- pure 18
  return $ a + b
```

and that will produce the same as if you had written:

```haskell
example :: MyMonad Int
example = Bind (Return 15) (\a -> Bind (Return 18) (\b -> Return (a + b)))
```

In the general sense, the monad abstraction is purely structural and does not
have much meaning; we can assign a meaning to this structure by writing an
interpreter for it. For this first dry run, let us just assign the simplest
possible meaning, which is that of executing each step in order. The skeleton
of our interpreter becomes:

```haskell
{-# LANGUAGE LambdaCase #-}

run :: MyMonad a -> a
run = \case
  Return a -> a
  Bind ma f -> run (f (run ma))
```

This is the simplest possible monad: it just sequences pure computations. I
claimed above that the essence of monads is to interleave pure computations and
effects; it would make sense that the simplest possible monad is the one with
no effect to interleave, but this does raise the question of how one might
represent effects when there are some. So let's look at a slightly less simple
case next.

### Revisiting Maybe

`Maybe` is a bit special in Haskell as it serves as both a "standard" data type
and a monadic one. This is compact and efficient, but it also muddies the
waters a bit, so let's revisit it through our new process here. First, we need
to think about the effects we want it to have. In the case of the `Maybe`
monad, the one effect we wanted to simulate was short-circuiting. We'll
represent this as a separate data constructor in our monad, and we'll therefore
call the monad `ShortCircuit`.

```haskell
instance Functor ShortCircuit where fmap = liftM
instance Applicative ShortCircuit where pure = return; (<*>) = ap
instance Monad ShortCircuit where return = SCReturn; (>>=) = SCBind

data ShortCircuit a where
  SCBind :: ShortCircuit a -> (a -> ShortCircuit b) -> ShortCircuit b
  SCReturn :: a -> ShortCircuit a
  SCStop :: ShortCircuit a
```

Yes, it's that easy: just add a type constructor for each effect you want to
simulate. Note that we had to add an `SC` prefix to all the names here because
I'm working through all these examples in [the same file][impl], and Haskell
wants all type names to be unique (hence `SCBind`, `SCReturn`, etc. instead of
`Bind`, `Return`, etc.).

We can rewrite the computation from [part one][one] as:

```haskell
exampleSC :: ShortCircuit Double
exampleSC = do
  r <- pure 5.0
  r <- pure $ r + 7.0
  r <- pure $ r - 2.0
  r <- sqr_inv r
  return $ r * 3.0
  where
  sqr_inv :: Double -> ShortCircuit Double
  sqr_inv a = do
    x <- pure a
    x <- sqrt x
    div 1.0 x
  sqrt :: Double -> ShortCircuit Double
  sqrt a = if a < 0.0 then SCStop else return $ a ** 0.5
  div :: Double -> Double -> ShortCircuit Double
  div a b = if b == 0 then SCStop else return $ a / b
```

This is pretty much the exact same code (translated to Haskell), except we're
now returning `SCStop` instead of `Nothing` to signal termination.

What should the meaning of that `SCStop` case be? If we hit it, we need to
signal to our caller that the computation did not properly terminate. If the
computation failed, we need to express the absence of a value, which we can do
by using a `Maybe`(using it strictly as a data structure, not as a monad, this
time):

```haskell
runSC :: ShortCircuit a -> Maybe a
runSC = \case
  SCReturn a -> Just a
  SCBind ma f -> case runSC ma of
    Nothing -> Nothing
    Just a -> runSC (f a)
  SCStop -> Nothing
```

Most of the power of the monad abstraction is already illustrated here, and
lies in the ability of the `run` method to make decisions on the result of
`run ma` as well as (not illustrated here) on the result of `f a`.

[GHC]: https://www.haskell.org/ghc/
[zero]: /posts/2021-04-11-monads-0
[one]: /posts/2021-04-18-monads-1
[two]: /posts/2021-04-25-monads-2
[impl]: https://github.com/gaverhae/cuddly-octo-palm-tree/blob/master/blog/minicode/2021-05-02/monad/app/Main.hs
