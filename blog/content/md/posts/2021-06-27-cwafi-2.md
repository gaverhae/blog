{:title "Cheap interpreter, part 2: tree-walking"
 :layout :post
 :tags ["cheap interpreter"]}

[Last week][part1] I described the general structure of an interpreter, and
gave a cursory introduction to parsing. From this point on, I will simply
assume I am starting with a parse tree, and ignore how it was produced.

This series is based on [Neil Mitchell][ndm]'s talk, [Cheaply writing a fast
interpeter][cwafi]. The talk compares a number of approaches to writing an
interpreter and tries to find a good balance between complexity and interpreter
overhead.

The following topics, while important, are out of scope:

- Parsing. We're assuming we start with a parse tree.
- Producing assembly code: the definition of "cheap" that Neil uses in the talk
  is "maintainers are not required to know another language" (specifically
  assembly).
- Semantic optimizations (constant folding, algebraic transformations, etc.).
  The goal is to compare the interpretation overhead of various approaches, and
  semantic optimizations are considered orthogonal to that.
- JIT is not explicitly excluded in the talk, but it is completely absent. This
  is probably also a consequence of the "cheap" constraint.

## Code sample

The talk uses a specific code snippet as the running example across all
approaches. We'll do the same. Here is the snippet as given in the talk:

```rust
x = 100;
for (i = 1000; i != 0; i--) {
  x = x + 4 + x + 3;
  x = x + 2 + 4;
}
x
```

The talk presents all of its approaches in [Rust], but I don't know Rust so I
made my explorations in a mix of [Haskell] and [Clojure]. I think there are
interesting things to say about both, I'll present both in this series.

The parse trees are going to look superficially different, but they encode the
exact same structure. Because Haskell does have a language to describe such
structure, we'll start with that:

```haskell
data Op
  = Add
  | NotEq
  deriving Show

data Exp
 = Lit Int
 | Var Int
 | Set Int Exp
 | Bin Op Exp Exp
 | Do Exp Exp
 | While Exp Exp
  deriving Show
```

This is not meant to be a complete language; it is only meant to cover the
specific operations we see in this one snippet. We have, in order:

- `Lit i`: literal values; for simplicity, we assume all values in the language
  are integers.
- `Var i`: access a variable from the environment. Again, for simplicity, we
  assume variable _names_ are integers. This can always be done, and usually
  is, because indexing by number is faster than looking up by string.
- `Set i e`: set the value of variable `i` to be the result of evaluating
  expression `e`. For example, `Set 0 (Lit 3)` would represent the instruction
  `x = 3`.
- `Bin op e1 e2`: apply the binary operator `op` to the results of evaluating
  expressions `e1` and `e2`, for example `Bin Add (Lit 3) (Lit 4)` would
  represent `3 + 4`.
- `Do e1 e2` is our main mean of sequencing operations. One could be tempted to
  represent a list of operations as a list, but representing it as a
  tree-shaped structure makes writing code against it easier. The structured
  representation becomes a bit more cumbersome, but keep in mind that in
  general this representation is produced by the parser.
- `While condition body` is our looping mechanism: we'll first evaluate the
  `condition`, and if it evaluates to 1, we'll evaluate the `body` and come
  back to `condition`.

We only need two binary operations for this snippet, so we could have just made
two entries in `Exp` called `Add Exp Exp` and `NotEq Exp Exp`, but, again,
isolating binary operations makes writing code against the representation
easier, because it makes the `Exp` type simpler. The tradeoff is that it makes
`Exp` _values_ more complex, but that is a tradeoff worth making.

With that representation, our canonical code snippet will look like:

```haskell
ast :: Exp
ast =
  -- x = 100
  (Do (Set 0 (Lit 100))
      -- i = 1000
      (Do (Set 1 (Lit 1000))
          -- for (; i != 0;)
          (Do (While (Bin NotEq (Lit 0)
                                (Var 1))
                     -- x = (((x + 4) + x) + 3)
                     (Do (Set 0 (Bin Add (Bin Add (Bin Add (Var 0)
                                                           (Lit 4))
                                                  (Var 0))
                                         (Lit 3)))
                         -- x = ((x + 2) + 4)
                         (Do (Set 0 (Bin Add (Bin Add (Var 0)
                                                      (Lit 2))
                                             (Lit 4)))
                             -- i = i + (-1)
                             (Set 1 (Bin Add (Lit (-1))
                                             (Var 1))))))
              -- return x
              (Var 0))))
```

The Clojure version is in direct correspondence:

```clojure
(def ast
  [:do
   [:set 0 [:lit 100]]
   [:do
    [:set 1 [:lit 1000]]
    [:do
     [:while
      [:bin :not= [:lit 0] [:var 1]]
      [:do
       [:set 0 [:bin :add [:bin :add [:bin :add [:var 0] [:lit 4]]
                                     [:var 0]]
                          [:lit 3]]]
       [:do
        [:set 0 [:bin :add [:bin :add [:var 0] [:lit 2]]
                           [:lit 4]]]
        [:set 1 [:bin :add [:lit -1] [:var 1]]]]]]
     [:var 0]]]])
```

[rust]: https://www.rust-lang.org
[clojure]: https://clojure.org
[haskell]: https://www.haskell.org
[part1]: /posts/2021-06-19-cwafi-1
[ndm]: https://ndmitchell.com
[cwafi]: https://www.youtube.com/watch?v=V8dnIw3amLA
