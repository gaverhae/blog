{:title "Notes on Optimizing Clojure Code 1: Overview"
 :layout :post
 :tags ["clojure"]}

Over the month of December, I've spent a lot of time trying to optimize my
solutions to [Advent of Code][aoc], with reasonable success. I thought I'd
collect my learnings in a set of notes for my future self, and share that with
you. Not all of this is Clojure-specific, but the details mostly are.

### Why optimize code?

For the sake of argument, let's assume you need to make your code faster
because it is too slow for the context it's being run in. In the case of Advent
of Code, I'm putting on myself the arbitrary constraint of running each day
under a second. That's pretty easy for the first few days, but gets a bit
harder on the later challenges.

In a more realistic context, maybe you have a website that's not as snappy as
you'd want, or you have to run a batch job every hour and it's taking 63
minutes and growing, or you have to run a script on your laptop and wait for it
to finish before you can do something else.

Whatever the details, context matters in two very specific ways:

1. It can tell us when to stop. Once your code is "fast enough", you don't need
   to optimize it further. Optimizing code often (though not always) comes at a
   cost to maintainability, so it should be done with some amount of reluctance on
   long-lived production code.
2. It tells us _how much_ code we need to care about. Specifically, all of the
   code involved in the realistic use-case that is currently "too slow", but
   not the rest of the code. This is really important if you want to be efficient
   in your optimization efforts, especially on large code bases.

### The process of optimizing code

In most cases, when a software application is too slow, the vast majority of
its time is spent in a very small fraction of the code, which we therefore call
"the bottleneck". Optimizing is an iterative process of:

1. Finding the current bottleneck.
2. Find a way to remove it.
3. Measure again. There are three options here:
    1. Your code is now _fast enough_, so you can stop.
    2. You find a new bottleneck. Iterate.
    3. Your code is still too slow but you can't identify a specific bottleneck.

That last case is _hard_. We'll get back to it.

In slightly more concrete terms, you'll want to:

1. Find a section of code that is too slow for some inputs. This is usually
   done with the help of some _profiling_ techniques.
2. Create a _benchmark_ that exercises that section of code with a
   representative set of inputs.
3. Iterate on the benchmark until it is fast enough. For practical reasons, you
   may want to do that in a separate project, or at least through a separate
   entrypoint in your application.

And that's the rough outline of this series. I'll write one post on profiling,
one on benchmarking, and then a series of posts about various optimization
techniques I've used.

[aoc]: https://adventofcode.com
