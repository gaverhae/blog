{:title "Optimizing Clojure code 1: Profiling"
 :layout :post
 :tags ["clojure"]}

Over the month of December, I've spent a lot of time trying to optimize my
solutions to [Advent of Code][aoc], with reasonable success, so I wanted to
share some of the techniques I've used there.

If you're thinking of optimizing some code, the very first step is finding out
what part of your code base is slow, preferably under realistic load. In this
series, I'll use the term _profiling_ to mean measuring, in some way, where
time is spent while the program runs. This is perhaps a bit broader than the
usual definition (which typically involves using a profiler), while also being
a bit more specific (profilers can also profile memory usage and other
characteristics).

There are three broad categories of profiling techniques I'll mention in this
post, in increasing order of effort:

- Typical logs.
- [timbre]-style profiling.
- Running a profiler.

### Why do we need to do this?

For the sake of argument, let's assume you need to make your code faster
because it is too slow for the context it's being run in. In the case of Advent
of Code, I'm putting on myself the goal of running each day under a second.
That's pretty easy for the first few days, but gets a bit harder on the later
challenges.

In a more realistic context, maybe you have a website that's not as snappy as
you'd want, or you have to run a batch job every hour and it's taking 63
minutes and growing, or you have to run a script on your laptop and wait for it
to finish before you can do something else.

Whatever the details, context matters in two very specific ways:

1. It can tell us when to stop. Once your code is "fast enough", you don't need
   to optimize it further. Optimizing code often (though not always) comes at a
   cost to maintainability, so it should be done with some amount of reluctance on
   long-lived production code.
2. It tells us _how much_ code we need to care about. Specifically, all of the
   code involved in the realistic use-case that is currently "too slow". This
   is really important if you want to be efficient in your optimization efforts.

In most cases, when a software application is too slow, the vast majority of
its time is spent in a very small fraction of the code, which we therefore call
"the bottleneck". Optimizing is an iterative process of "removing" the
bottleneck, and then finding the next one.

Which raises two questions: how do you find the bottleneck, and how do you
remove it? This post is about the former; future posts will address the latter.

### Logs

If the code you're looking at is a long-running application, chances are you
already have some form of logs for general debugging. It is possible that those
logs are sufficient for you to pinpoint reasonably accurately where the most
amount of time is spent, or at least to eliminate large chunks of code as "fast
enough". If you have a batch job that prints ten lines of log almost
instantily, then seemingly does nothing for ten minutes and prints one more
line before ending, you can reasonably assume that you only need to look a the
code executed between the last two prints.

Depending on how the code is organized, finding out what portion of the code
that represents may be more or less easy. Furthermore, maybe 95% of the code
_is_ between these two prints, and therefore you haven't gained much.

Still, in many cases, it should be fairly easy to find which portion of the
code is between these two prints, and it may be relatively small, too.




[aoc]: https://adventofcode.com
[timbre]: https://github.com/ptaoussanis/timbre
